{"version":3,"sources":["src/index.js"],"names":["Crawler","constructor","options","_options","Object","assign","titleProgress","showProgress","maxRequest","skipStrictDuplicates","sameOrigin","maxDepth","parallel","_requestedCount","hostdomain","linksToCrawl","Map","linksCrawled","_actions","preRequest","x","onSuccess","evaluatePage","progressCli","init","url","Error","link","URL","origin","error","sanitizedUrl","shouldRequest","linksCollected","scrapePage","set","length","console","log","_cliProgress","Bar","format","barsize","Presets","shades_classic","addToQueue","size","start","crawl","stop","collectAnchors","$","actualHref","protocol","allLinks","map","i","e","href","attr","startsWith","filter","get","Set","skipRequest","allowOrigin","checkSameOrigin","linkAlreadyCollected","Function","message","evaluate","result","urlCollected","depth","Promise","resolve","reject","canceled","currentCrawlers","pullQueue","checkMaxRequest","currentLink","keys","next","value","currentDepth","delete","setTotal","update","pull","then","catch","scrapeSucceed","urlScraped","has","retriedFetch","fetch","textBuffer","textResponse","text","cheerio","load","all","launch","startCrawlingAt","Date","crawler","finishCrawlingAt","linksVisited"],"mappings":"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","sourceRoot":"..","sourcesContent":["import { retryRequest, isUrl } from './utils'\nimport fetch from 'node-fetch'\nimport cheerio from 'cheerio'\nimport _cliProgress from 'cli-progress'\n\nclass Crawler {\n  constructor(options) {\n    this._options = Object.assign(\n      {},\n      {\n        titleProgress: 'Crawl in progress',\n        showProgress: true,\n        maxRequest: -1,\n        skipStrictDuplicates: true,\n        sameOrigin: true,\n        maxDepth: 3,\n        parallel: 5\n      },\n      options\n    )\n    this._requestedCount = 0\n    this.hostdomain = ''\n    this.linksToCrawl = new Map()\n    this.linksCrawled = new Map()\n    this._actions = {\n      preRequest: this._options.preRequest || (x => x),\n      onSuccess: this._options.onSuccess || null,\n      evaluatePage: this._options.evaluatePage || null\n    }\n    this.progressCli = null\n  }\n\n  /**\n   * Init the app. Begin with the first link, and start the pulling\n   * @return {!Promise<pending>}\n   */\n  async init() {\n    try {\n      if (!isUrl(this._options.url)) throw new Error()\n      const link = new URL(this._options.url)\n      this.hostdomain = link.origin\n    } catch (error) {\n      throw new Error('URL provided is not valid')\n    }\n\n    if (!this.hostdomain) return\n    const sanitizedUrl = await this.shouldRequest(this._options.url)\n    if (!sanitizedUrl) return\n    const { linksCollected } = await this.scrapePage(sanitizedUrl)\n    this.linksCrawled.set(sanitizedUrl)\n    this._requestedCount++\n    if (linksCollected.length === 0) return\n    if (this._options.showProgress) {\n      console.log('')\n      this.progressCli = new _cliProgress.Bar(\n        {\n          format: `${this._options.titleProgress} [{bar}] {percentage}% | {value}/{total} | Parallel: ${\n            this._options.parallel\n          } | MaxRequest: ${this._options.maxRequest} | MaxDepth ${this._options.maxDepth}`,\n          barsize: 25\n        },\n        _cliProgress.Presets.shades_classic\n      )\n    }\n    await this.addToQueue(linksCollected, 1)\n    if (this.linksToCrawl.size > 0) {\n      this._options.showProgress && this.progressCli.start(this.linksToCrawl.size, 0)\n      await this.crawl()\n      this._options.showProgress && this.progressCli.stop()\n    }\n  }\n\n  /**\n   * Get all links from the page except the actual location\n   * @param {!Page} page\n   * @return {!Promise<Array<string>>}\n   */\n  collectAnchors($, actualHref) {\n    const { origin, protocol } = new URL(actualHref)\n    const allLinks = $('a')\n      .map((i, e) => {\n        const href = $(e).attr('href') || ''\n        if (href.startsWith('//')) return protocol + href\n        else if (href.startsWith('/')) return origin + href\n        else return href\n      })\n      .filter((i, href) => isUrl(href))\n      .get()\n    return [...new Set(allLinks)]\n  }\n\n  /**\n   * Check if link can be crawled (Same origin ? Already collected ? preRequest !false ?)\n   * @param {!string} link\n   * @return {!Promise<Boolean>}\n   */\n  async skipRequest(link) {\n    const allowOrigin = this.checkSameOrigin(link)\n    if (!allowOrigin) return true\n    if (this._options.skipStrictDuplicates && this.linkAlreadyCollected(link)) return true\n    const shouldRequest = await this.shouldRequest(link)\n    if (!shouldRequest) return true\n    return false\n  }\n\n  /**\n   * If preRequest is provided by the user, get new link or false\n   * @param {!string} link\n   * @return {!Promise<String || Boolean>}\n   */\n  async shouldRequest(link) {\n    if (this._actions.preRequest instanceof Function) {\n      try {\n        const preRequest = await this._actions.preRequest(link)\n        if (typeof preRequest === 'string' || preRequest === false) {\n          return preRequest\n        }\n        throw new Error('preRequest function must return a string or false')\n      } catch (error) {\n        console.error('Please try/catch your preRequest function')\n        console.log(error.message)\n      }\n    }\n    return link\n  }\n\n  /**\n   * Check if link has the same origin as the host link\n   * @param {!String} url\n   * @return {!Boolean}\n   */\n  checkSameOrigin(url) {\n    if (this._options.sameOrigin) return new URL(url).origin === this.hostdomain\n    return true\n  }\n\n  /**\n   * If evaluatePage is provided by the user, await for it\n   * @param {!Page} page\n   * @return {!Promise<any>}\n   */\n  async evaluate($) {\n    let result = null\n    if (this._actions.evaluatePage && this._actions.evaluatePage instanceof Function) {\n      result = await this._actions.evaluatePage($)\n    }\n    return result\n  }\n\n  /**\n   * Add links collected to queue\n   * @param {!Array<string>} urlCollected\n   * @param {!Number} depth\n   * @return {!Promise<pending>}\n   */\n  async addToQueue(urlCollected, depth = 0) {\n    for (let url of urlCollected) {\n      if (depth <= this._options.maxDepth && !(await this.skipRequest(url))) {\n        url = await this.shouldRequest(url)\n        this.linksToCrawl.set(url, depth)\n      }\n    }\n  }\n\n  crawl() {\n    return new Promise((resolve, reject) => {\n      let canceled = false\n      let currentCrawlers = 0\n      const pullQueue = () => {\n        if (canceled) return\n        while (currentCrawlers < this._options.parallel && this.linksToCrawl.size > 0) {\n          canceled = !this.checkMaxRequest()\n          if (canceled) {\n            currentCrawlers === 0 && resolve()\n            break\n          }\n          currentCrawlers++\n          const currentLink = this.linksToCrawl.keys().next().value\n          const currentDepth = this.linksToCrawl.get(currentLink)\n          this.linksToCrawl.delete(currentLink)\n          this.linksCrawled.set(currentLink)\n          this._options.showProgress && this.progressCli.setTotal(this.linksToCrawl.size + this.linksCrawled.size)\n          this._options.showProgress && this.progressCli.update(this.linksCrawled.size)\n          this.pull(currentLink, currentDepth)\n            .then(() => {\n              currentCrawlers--\n              if (currentCrawlers === 0 && this.linksToCrawl.size === 0) resolve()\n              if (currentCrawlers === 0 && canceled) resolve()\n              else pullQueue()\n            })\n            .catch(error => {\n              canceled = true\n              reject(error)\n            })\n        }\n      }\n      pullQueue()\n    })\n  }\n\n  async pull(link, depth) {\n    try {\n      const { result, linksCollected } = await this.scrapePage(link)\n      await this.scrapeSucceed({ urlScraped: link, result })\n      await this.addToQueue(linksCollected, depth + 1)\n    } catch (error) {\n      console.error(error)\n    }\n  }\n\n  /**\n   * Get if a link will be crawled or has already been crawled.\n   * @param {!String} url\n   * @return {!Boolean}\n   */\n  linkAlreadyCollected(url) {\n    return this.linksCrawled.has(url) || this.linksToCrawl.has(url)\n  }\n\n  /**\n   * Know if we have exceeded the number of request max provided in the options.\n   * @return {!Boolean}\n   */\n  checkMaxRequest() {\n    if (this._options.maxRequest === -1) return true\n    return this.linksCrawled.size < this._options.maxRequest\n  }\n\n  /**\n   * If onSuccess action's has been provided, await for it.\n   * @param {!Object<{urlScraped: string, result}>}\n   * @return {!Promise<pending>}\n   */\n  async scrapeSucceed({ urlScraped, result }) {\n    if (this._actions.onSuccess && this._actions.onSuccess instanceof Function) {\n      try {\n        await this._actions.onSuccess({ result, url: urlScraped })\n      } catch (error) {\n        console.error('Please try/catch your onSuccess function')\n      }\n    }\n  }\n\n  /**\n   * Scrap a page, evaluate and get new links to visit.\n   * @param {!String} url\n   * @return {Promise<{linksCollected: array, result, url: string}>}\n   */\n  async scrapePage(url) {\n    const retriedFetch = retryRequest(fetch, 2)\n    try {\n      const textBuffer = await retriedFetch(url)\n      const textResponse = await textBuffer.text()\n      const $ = cheerio.load(textResponse)\n      const [result, linksCollected] = await Promise.all([this.evaluate($), this.collectAnchors($, url)])\n      return { linksCollected, result, url }\n    } catch (error) {\n      console.error(error)\n      return {\n        linksCollected: [],\n        result: null,\n        url\n      }\n    }\n  }\n\n  /**\n   * Starting the crawl.\n   * @param {!0bject} options\n   * @return {Promise<{startCrawlingAt: date, finishCrawlingAt: date, linksVisited: array}>}\n   */\n  static async launch(options) {\n    const startCrawlingAt = new Date()\n    const crawler = new Crawler(options)\n    await crawler.init()\n    const finishCrawlingAt = new Date()\n    return { startCrawlingAt, finishCrawlingAt, linksVisited: crawler.linksCrawled.size }\n  }\n}\n\nexport default Crawler\n"],"file":"index.js"}